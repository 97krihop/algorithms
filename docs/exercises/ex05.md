# Exercise 05


## Part A

Write a class called `BinaryTreeLeftMaxDelete` that does extend `MyMapBinaryTree`.
In such class, override the method:

```
protected TreeNode delete(K key, TreeNode subtreeRoot)
```

When a node with two children needs to be deleted, instead of replacing it with the min
value from the right-subtree, do use the max value from the left-subtree.

Write a test class `BinaryTreeLeftMaxDeleteTest` that extends `MyMapBinaryTreeTest`,
in which you override the method `getTreeInstance()` to use an instance of
`BinaryTreeLeftMaxDelete`.
If your implementation is correct, all tests should pass. 

## Part B

Write a class called `TernaryTreeMap` that extends `MyMapTreeBased`.
This class should be similar to `MyMapBinaryTree`, but with a major difference:
each node contains two elements (`first` and `second`), instead of just one, and three children
(`left`, `middle` and `right`).
Their ordering relation should be `left < first < middle < second < right`.

Write a test class called `TernaryTreeMapTest` that extends `MyMapTestTemplate`.
If your implementation of `TernaryTreeMap` is correct, then all tests should pass.
Similarly to `MyMapBinaryTreeTest`,
add these further new tests:
* Add 2 distinct elements in a way that the tree depth is only 1 (ie, best case for 2 insertions).
* Add 3 distinct elements in a way that the tree depth is 3 (ie, worst case for 3 insertions).
* Add 8 distinct elements in a way that the tree depth is only 2 (ie, best case for 8 insertions).

## Part C

Study the source code of `MyMapBinaryTree`.
Once you think you fully understand it, write its implementation
on paper (e.g., using a pen), without looking at the source code.
Once done, compare what you wrote with the actual implementation. 

## Solutions

Solutions to this exercise can be found in the `solutions`
module, under the `org.pg4200.sol05` package.